"use strict";(globalThis.webpackChunkgoose=globalThis.webpackChunkgoose||[]).push([[2556],{11763:e=>{e.exports=JSON.parse('{"permalink":"/goose/blog/2025/12/19/does-your-ai-agent-need-a-plan","source":"@site/blog/2025-12-19-does-your-ai-agent-need-a-plan/index.md","title":"Does Your AI Agent Need a Plan?","description":"Planning with an AI produces good results. Knowing when and how to plan with an AI agent produces even better ones.","date":"2025-12-19T00:00:00.000Z","tags":[],"readingTime":6.75,"hasTruncateMarker":true,"authors":[{"name":"Rizel Scarlett","title":"Staff Developer Advocate","page":{"permalink":"/goose/blog/authors/rizel"},"socials":{"x":"https://x.com/blackgirlbytes","github":"https://github.com/blackgirlbytes","bluesky":"https://bsky.app/profile/blackgirlbytes.bsky.social","linkedin":"https://www.linkedin.com/in/rizel-bobb-semple/"},"imageURL":"https://avatars.githubusercontent.com/u/22990146?v=4","key":"rizel"}],"frontMatter":{"title":"Does Your AI Agent Need a Plan?","description":"Planning with an AI produces good results. Knowing when and how to plan with an AI agent produces even better ones.","authors":["rizel"]},"unlisted":false,"prevItem":{"title":"Code Mode Doesn\'t Replace MCP (Here\'s What It Actually Does)","permalink":"/goose/blog/2025/12/21/code-mode-doesnt-replace-mcp"},"nextItem":{"title":"goose Mobile Access and Native Terminal Support","permalink":"/goose/blog/2025/12/19/goose-mobile-terminal"}}')},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var o=n(96540);const s={},a=o.createContext(s);function r(e){const t=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(a.Provider,{value:t},e.children)}},54951:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var o=n(11763),s=n(74848),a=n(28453);const r={title:"Does Your AI Agent Need a Plan?",description:"Planning with an AI produces good results. Knowing when and how to plan with an AI agent produces even better ones.",authors:["rizel"]},i="Does Your AI Agent Need a Plan?",c={authorsImageUrls:[void 0]},h=[{value:"Choose Your Strategy",id:"choose-your-strategy",level:2},{value:"For The Architect",id:"for-the-architect",level:3},{value:"For The Director",id:"for-the-director",level:3},{value:"For The Explorer",id:"for-the-explorer",level:3},{value:"What&#39;s Your Style?",id:"whats-your-style",level:2}];function l(e){const t={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",p:"p",strong:"strong",...(0,a.R)(),...e.components},{Head:o}=t;return o||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"blog cover",src:n(98052).A+"",width:"1206",height:"633"})}),"\n",(0,s.jsx)(t.p,{children:"To plan or not to plan, that's the wrong question. Rather than a binary yes/no, planning exists on a spectrum. The real question is which approach fits your current task and working style."}),"\n",(0,s.jsx)(t.p,{children:'Different developers approach planning in different ways. One builder might draft detailed pseudocode before touching a keyboard, while another practices test driven development to let the architecture emerge organically. You\'ll find teams sketching complex diagrams on whiteboards and others spinning up fast prototypes to "fail fast" and refactor later.'}),"\n",(0,s.jsx)(t.p,{children:"If planning is a spectrum when coding manually, why wouldn't it be a spectrum when using an agent to code as well?"}),"\n",(0,s.jsx)(t.p,{children:'Lately, there\'s been a healthy debate in the industry about planning in AI coding agents. While some find dedicated plan modes essential, others see them as unnecessary overhead. After all, you can always just tell an agent to "make a plan first." Some even argue that if you need a durable plan, you should write it in a file yourself so you can see it, edit it, and version it alongside your code.'}),"\n",(0,s.jsx)(t.p,{children:"This reveals an interesting truth: the value of a plan mode isn't just about the plan itself. It's about creating the right mental model and workflow for the developer using it. Sometimes you want the agent to just execute. Other times, you want to see its thinking, provide feedback, and collaborate on the approach before any code changes happen."}),"\n",(0,s.jsxs)(t.p,{children:["Rather than picking one philosophy, ",(0,s.jsx)(t.a,{href:"https://github.com/block/goose",children:"goose"})," supports multiple approaches because different situations call for different methods."]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"choose-your-strategy",children:"Choose Your Strategy"}),"\n",(0,s.jsx)(t.h3,{id:"for-the-architect",children:"For The Architect"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"/plan"})," Mode"]})}),"\n",(0,s.jsxs)(t.p,{children:["When you enter ",(0,s.jsx)(t.a,{href:"/docs/guides/creating-plans",children:"plan mode"})," in the goose CLI, goose shifts into an interactive dialogue. Instead of immediately executing, it asks clarifying questions to understand your project deeply. It might ask about your tech stack preferences, authentication requirements, deployment targets, or how you want to handle error cases. This back and forth continues until goose has enough context to generate a comprehensive, actionable plan."]}),"\n",(0,s.jsxs)(t.p,{children:["Plan mode uses a separate planner configuration that you can customize. By setting ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"GOOSE_PLANNER_PROVIDER"})})," and ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"GOOSE_PLANNER_MODEL"})})," ",(0,s.jsx)(t.a,{href:"/docs/guides/environment-variables",children:"environment variables"}),", you can use one model for strategic planning and a different model for execution. When you're satisfied with the plan, goose asks if you want to clear the message history and act on it, giving you a clear checkpoint before any code changes happen."]}),"\n",(0,s.jsx)(t.p,{children:'I used this approach recently when converting a static Vite/React project to Next.js. I understood the scope clearly since it\'s a common migration pattern, so I asked goose to make a comprehensive plan before starting any work. It produced an 11 phase migration plan with specific checkboxes for each step, covering everything from dependency updates to routing changes to component boundaries. Once I approved, I said "yes start" and goose executed methodically, committing after each phase.'}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"/docs/guides/creating-plans",children:"Learn more about creating plans \u2192"})}),"\n",(0,s.jsx)(t.h3,{id:"for-the-director",children:"For The Director"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Instruction Files"})}),"\n",(0,s.jsx)(t.p,{children:"Sometimes you already know exactly what needs to happen. You've thought through the steps, you've made the decisions, and you just need goose to do the work. Instead of explaining your plan through conversation, you write it down and hand it over."}),"\n",(0,s.jsxs)(t.p,{children:["You can write your instructions in a markdown file as a detailed execution plan, a living document that guides goose through implementation step by step. The plan can include context about the codebase, specific files to modify, expected outcomes, and validation steps. When you're ready, you ",(0,s.jsx)(t.a,{href:"/docs/guides/running-tasks",children:"run it"})," with ",(0,s.jsx)(t.code,{children:"goose run -i plan.md"})," and goose executes what you've specified."]}),"\n",(0,s.jsx)(t.p,{children:"This approach works when you've already done the thinking. Maybe you sketched the architecture on a whiteboard. Maybe you wrote a technical design doc. Maybe you just know this codebase well enough that you don't need goose to ask clarifying questions. You write the spec, goose executes it."}),"\n",(0,s.jsxs)(t.p,{children:["You can also run instruction files in ",(0,s.jsx)(t.a,{href:"/docs/tutorials/headless-goose",children:"headless mode"})," for CI/CD pipelines or automation, but that's just one use case. The core idea is: you own the plan, goose owns the execution."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"/docs/guides/running-tasks",children:"Learn more about running tasks \u2192"})}),"\n",(0,s.jsx)(t.h3,{id:"for-the-explorer",children:"For The Explorer"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Conversational Context Building"})}),"\n",(0,s.jsx)(t.p,{children:"This approach combines three goose features that work together:"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Conversational planning"})," means treating goose as a pairing partner rather than a task executor. You ask goose to analyze, explain, and explore. You build a shared mental model together. Then, when you're ready, you shift into execution."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:["The ",(0,s.jsx)(t.a,{href:"/docs/mcp/todo-mcp",children:"todo extension"})]})," watches for complexity in the background. When goose recognizes that a task has two or more steps, involves multiple files, or has uncertain scope, it automatically creates a checklist. As goose works, it updates progress and checks off completed items. The plan emerges from the work rather than preceding it."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Project rules"})," provide invisible scaffolding. Using files like ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"/docs/guides/context-engineering/using-goosehints",children:(0,s.jsx)(t.code,{children:"goosehints"})})})," or ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"agents.md"})}),", you encode persistent preferences, commit policies, testing requirements, project conventions, that automatically steer the agent in the right direction. This gives goose the context to make better decisions without you repeating the rules every time."]}),"\n",(0,s.jsx)(t.p,{children:"Together, these features let you have a casual, exploratory conversation while maintaining structure underneath. You scope your prompts deliberately. The todo extension creates organization when complexity appears. The project rules ensure your preferences are always in play."}),"\n",(0,s.jsx)(t.p,{children:"This is typically how I work. When I migrated a legacy LLM credit provisioning app to Next.js, many cringed at my approach. However, in context, I was returning to a codebase I'd built eight months earlier and didn't remember well. The app was split across two repositories and I didn't know which one handled what. Writing a plan.md file upfront would have been guessing."}),"\n",(0,s.jsx)(t.p,{children:'So I asked goose to analyze both projects and explain how they communicated. I scoped my prompts deliberately: "just the frontend, no API calls." I had the todo extension enabled, knowing it would create structure once the scope became clear. I had project rules configured to handle commits automatically.'}),"\n",(0,s.jsx)(t.p,{children:"The approach took more back and forth than an upfront plan would have. But those prompts weren't wasted effort. They were building the context that made the actual migration possible. By the time goose created its checklist, we both understood what needed to happen."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"/docs/mcp/todo-mcp",children:"Learn more about the todo extension \u2192"}),(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.a,{href:"/docs/guides/context-engineering/using-goosehints",children:"Configure your project rules with goosehints \u2192"})]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"whats-your-style",children:"What's Your Style?"}),"\n",(0,s.jsx)(t.p,{children:"goose supports multiple planning philosophies because developers don't work in a single mode. The architect wants clarity before code. The director wants control. The explorer discovers the plan through the work."}),"\n",(0,s.jsxs)(t.p,{children:["None of these approaches is superior. Each fits different situations. The same developer might use ",(0,s.jsx)(t.code,{children:"/plan"})," mode for a well scoped migration on Monday and conversational context building for an unfamiliar codebase on Tuesday."]}),"\n",(0,s.jsx)(t.p,{children:"The question isn't whether to plan. The question is which kind of planning fits your situation today."}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["Ready to try different planning approaches with goose? Start with our ",(0,s.jsx)(t.a,{href:"/docs/quickstart",children:"quickstart guide"})," or explore the ",(0,s.jsx)(t.a,{href:"/docs/guides/context-engineering",children:"context engineering documentation"})," to set up your scaffolding."]})}),"\n",(0,s.jsxs)(o,{children:[(0,s.jsx)("meta",{property:"og:title",content:"Does Your AI Agent Need a Plan?"}),(0,s.jsx)("meta",{property:"og:type",content:"article"}),(0,s.jsx)("meta",{property:"og:url",content:"https://block.github.io/goose/blog/2025/12/19/does-your-ai-agent-need-a-plan"}),(0,s.jsx)("meta",{property:"og:description",content:"Planning with an AI produces good results. Knowing when and how to plan with an AI agent produces even better ones."}),(0,s.jsx)("meta",{property:"og:image",content:"https://block.github.io/goose/assets/images/blog-banner-69252aa3455f8a3a303f102c530922f3.png"}),(0,s.jsx)("meta",{name:"twitter:card",content:"summary_large_image"}),(0,s.jsx)("meta",{property:"twitter:domain",content:"block.github.io/goose"}),(0,s.jsx)("meta",{name:"twitter:title",content:"Does Your AI Agent Need a Plan?"}),(0,s.jsx)("meta",{name:"twitter:description",content:"Planning with an AI produces good results. Knowing when and how to plan with an AI agent produces even better ones."}),(0,s.jsx)("meta",{name:"twitter:image",content:"https://block.github.io/goose/assets/images/blog-banner-69252aa3455f8a3a303f102c530922f3.png"}),(0,s.jsx)("meta",{name:"keywords",content:"goose, AI planning, AI agents, plan mode, developer workflow, context engineering, goosehints, todo extension, AI coding assistant, software development"})]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},98052:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/blog-banner-69252aa3455f8a3a303f102c530922f3.png"}}]);