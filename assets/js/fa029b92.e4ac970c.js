"use strict";(globalThis.webpackChunkgoose=globalThis.webpackChunkgoose||[]).push([[1894],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(96540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}},87962:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>m,frontMatter:()=>c,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"tutorials/rpi","title":"Research \u2192 Plan \u2192 Implement Pattern","description":"How to use RPI, a context engineering technique, on complex software projects","source":"@site/docs/tutorials/rpi.md","sourceDirName":"tutorials","slug":"/tutorials/rpi","permalink":"/goose/docs/tutorials/rpi","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Research \u2192 Plan \u2192 Implement Pattern","description":"How to use RPI, a context engineering technique, on complex software projects"},"sidebar":"tutorialSidebar","previous":{"title":"Recipes","permalink":"/goose/docs/tutorials/recipes-tutorial"},"next":{"title":"Subrecipes In Parallel","permalink":"/goose/docs/tutorials/subrecipes-in-parallel"}}');var s=t(74848),r=t(28453),a=t(83457);const i='---\ndate: 2025-12-22T23:43:05-06:00\ngit_commit: 2f876725d3c08f821358e1391a7daadf468193d8\nbranch: remove-llm-tool-discovery\nrepository: goose\ntopic: "LLM Tool Selection Strategy (Tool Discovery Feature)"\ntags: [research, codebase, tools, router, llm-selection, experimental]\nstatus: complete\n---\n\n# Research: LLM Tool Selection Strategy\n\n## Research Question\nHow is the "Tool Selection Strategy" feature implemented? This is the experimental feature that uses "LLM-based intelligence to select the most relevant tools based on the user query context."\n\n## Summary\n\nThe **Tool Selection Strategy** is an experimental feature (preview) that dynamically filters which tools are presented to the LLM based on the user\'s query. Instead of sending all tools from all extensions to the LLM, it:\n\n1. Provides a single `router__llm_search` tool to the main LLM\n2. When invoked, uses a secondary LLM call to search indexed tools and return only relevant ones\n3. Tracks recently used tools to include them automatically\n\nThis saves context window space when many extensions are enabled.\n\n**Configuration**: `GOOSE_ENABLE_ROUTER` (boolean, default: false)\n\n## Detailed Findings\n\n### 1. Feature Toggle - Configuration\n\nThe feature is controlled by the `GOOSE_ENABLE_ROUTER` config parameter:\n\n**File: `crates/goose/src/agents/tool_route_manager.rs:79-86`**\n```rust\npub async fn is_router_enabled(&self) -> bool {\n    if *self.router_disabled_override.lock().await {\n        return false;\n    }\n\n    let config = Config::global();\n    if let Ok(config_value) = config.get_param::<String>("GOOSE_ENABLE_ROUTER") {\n        return config_value.to_lowercase() == "true";\n    }\n\n    // Default to false if neither is set\n    false\n}\n```\n\n**UI Toggle: `ui/desktop/src/components/settings/tool_selection_strategy/ToolSelectionStrategySection.tsx`**\n- Displays "Disabled" (default) and "Enabled" radio options\n- Updates `GOOSE_ENABLE_ROUTER` config via upsert\n- Calls `/agent/update_router_tool_selector` endpoint to reinitialize\n\n### 2. Core Components\n\n#### 2.1 ToolRouteManager\n**File: `crates/goose/src/agents/tool_route_manager.rs`**\n\nCentral manager that:\n- Holds the `RouterToolSelector` instance\n- Checks if router is enabled/functional\n- Dispatches search tool calls\n- Provides tools for router mode\n\n```rust\npub struct ToolRouteManager {\n    router_tool_selector: Mutex<Option<Arc<Box<dyn RouterToolSelector>>>>,\n    router_disabled_override: Mutex<bool>,  // For recipes that need all tools\n}\n```\n\nKey methods:\n- `is_router_enabled()` - Checks config\n- `is_router_functional()` - Enabled AND selector initialized\n- `dispatch_route_search_tool()` - Handles `router__llm_search` calls\n- `list_tools_for_router()` - Returns search tool + recently used tools\n\n#### 2.2 RouterToolSelector Trait & LLMToolSelector\n**File: `crates/goose/src/agents/router_tool_selector.rs`**\n\n```rust\n#[async_trait]\npub trait RouterToolSelector: Send + Sync {\n    async fn select_tools(&self, params: JsonObject) -> Result<Vec<Content>, ErrorData>;\n    async fn index_tools(&self, tools: &[Tool], extension_name: &str) -> Result<(), ErrorData>;\n    async fn remove_tool(&self, tool_name: &str) -> Result<(), ErrorData>;\n    async fn record_tool_call(&self, tool_name: &str) -> Result<(), ErrorData>;\n    async fn get_recent_tool_calls(&self, limit: usize) -> Result<Vec<String>, ErrorData>;\n}\n```\n\n**LLMToolSelector** implementation:\n- Stores tool strings indexed by extension name\n- Uses an LLM provider to search tools based on query\n- Tracks last 100 tool calls for "recently used" feature\n\n#### 2.3 The Search Tool Definition\n**File: `crates/goose/src/agents/router_tools.rs`**\n\n```rust\npub const ROUTER_LLM_SEARCH_TOOL_NAME: &str = "router__llm_search";\n\npub fn llm_search_tool() -> Tool {\n    Tool::new(\n        ROUTER_LLM_SEARCH_TOOL_NAME.to_string(),\n        r#"Searches for relevant tools based on the user\'s messages.\n        Format a query to search for the most relevant tools...\n        Extension name is not optional, it is required.\n        The returned result will be a list of tool names, descriptions, and schemas..."#,\n        // Schema requires: extension_name (string), query (string), optional k (integer)\n    )\n}\n```\n\n#### 2.4 Tool Indexing Manager\n**File: `crates/goose/src/agents/tool_router_index_manager.rs`**\n\nHandles indexing/removing tools when extensions are added/removed:\n\n```rust\nimpl ToolRouterIndexManager {\n    pub async fn update_extension_tools(\n        selector: &Arc<Box<dyn RouterToolSelector>>,\n        extension_manager: &ExtensionManager,\n        extension_name: &str,\n        action: &str,  // "add" or "remove"\n    ) -> Result<()>\n}\n```\n\n### 3. Flow: How Tool Selection Works\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    INITIALIZATION                               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1. User enables "Tool Selection Strategy" in settings           \u2502\n\u2502 2. GOOSE_ENABLE_ROUTER = "true" saved to config                 \u2502\n\u2502 3. /agent/update_router_tool_selector called                    \u2502\n\u2502 4. ToolRouteManager.update_router_tool_selector():              \u2502\n\u2502    a. Creates LLMToolSelector with provider                     \u2502\n\u2502    b. Indexes all tools from all enabled extensions             \u2502\n\u2502    c. Stores selector in router_tool_selector mutex             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    TOOL LISTING (Router Mode)                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 When agent.list_tools() is called with router enabled:          \u2502\n\u2502                                                                 \u2502\n\u2502 Instead of returning ALL tools, returns:                        \u2502\n\u2502   1. router__llm_search tool                                    \u2502\n\u2502   2. Recently used tools (last 20 calls)                        \u2502\n\u2502   3. Platform tools (extension manager, etc.)                   \u2502\n\u2502                                                                 \u2502\n\u2502 This dramatically reduces context sent to LLM                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    RUNTIME: User Query                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1. User: "list files in current directory"                      \u2502\n\u2502 2. LLM sees router__llm_search tool in available tools          \u2502\n\u2502 3. LLM invokes: router__llm_search(                             \u2502\n\u2502      extension_name: "developer",                               \u2502\n\u2502      query: "list files directory"                              \u2502\n\u2502    )                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    SEARCH EXECUTION                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Agent.dispatch_tool_call() routes to:                           \u2502\n\u2502   ToolRouteManager.dispatch_route_search_tool()                 \u2502\n\u2502     \u2192 LLMToolSelector.select_tools()                            \u2502\n\u2502                                                                 \u2502\n\u2502 LLMToolSelector:                                                \u2502\n\u2502   1. Gets indexed tool strings for extension                    \u2502\n\u2502   2. Renders router_tool_selector.md prompt template            \u2502\n\u2502   3. Calls LLM provider with tool list + query                  \u2502\n\u2502   4. Parses response for "Tool: X\\nDescription: Y\\nSchema: Z"   \u2502\n\u2502   5. Returns matching tools as Content                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    LLM RECEIVES RESULTS                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Main LLM receives tool definitions in response                  \u2502\n\u2502 Can now invoke the actual tool (e.g., developer__shell)         \u2502\n\u2502 Tool call is recorded for "recently used" feature               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 4. System Prompt Integration\n\n**File: `crates/goose/src/agents/prompt_manager.rs`**\n\nWhen router is enabled, the system prompt includes special instructions:\n\n```rust\ntool_selection_strategy: self.router_enabled.then(llm_search_tool_prompt),\n```\n\n**File: `crates/goose/src/agents/router_tools.rs:41-57`**\n```rust\npub fn llm_search_tool_prompt() -> String {\n    format!(\n        r#"# LLM Tool Selection Instructions\n    Important: the user has opted to dynamically enable tools, so although an extension could be enabled, \\\n    please invoke the llm search tool to actually retrieve the most relevant tools to use according to the user\'s messages.\n    ...\n    By dynamically enabling tools, you (goose) as the agent save context window space and allow the user to dynamically retrieve the most relevant tools.\n    "#,\n        // Lists platform extension tools that are always available\n    )\n}\n```\n\nThis is injected into `system.md` via `{{tool_selection_strategy}}`.\n\n### 5. LLM Search Prompt Template\n\n**File: `crates/goose/src/prompts/router_tool_selector.md`**\n```markdown\nYou are a tool selection assistant. Your task is to find the most relevant tools based on the user\'s query.\n\nGiven the following tools:\n{{ tools }}\n\nFind the most relevant tools for the query: {{ query }}\n\nReturn the tools in this exact format for each tool:\nTool: <tool_name>\nDescription: <tool_description>\nSchema: <tool_schema>\n```\n\n### 6. Server Endpoint\n\n**File: `crates/goose-server/src/routes/agent.rs`**\n\n```rust\n#[utoipa::path(\n    post,\n    path = "/agent/update_router_tool_selector",\n    ...\n)]\nasync fn update_router_tool_selector(\n    State(state): State<Arc<AppState>>,\n    Json(payload): Json<UpdateRouterToolSelectorRequest>,\n) -> Result<Json<String>, StatusCode> {\n    let agent = state.get_agent_for_route(payload.session_id).await?;\n    agent\n        .update_router_tool_selector(None, Some(true))  // reindex_all = true\n        .await\n        .map_err(...)?;\n\n    Ok(Json("Tool selection strategy updated successfully".to_string()))\n}\n```\n\n### 7. Recipe Override\n\nRecipes can disable the router to ensure all tools are available:\n\n**File: `crates/goose/src/agents/tool_route_manager.rs:31-34`**\n```rust\npub async fn disable_router_for_recipe(&self) {\n    *self.router_disabled_override.lock().await = true;\n    *self.router_tool_selector.lock().await = None;\n}\n```\n\n## Code References\n\n### Core Implementation\n- `crates/goose/src/agents/tool_route_manager.rs` - Main manager, config check, dispatch\n- `crates/goose/src/agents/router_tool_selector.rs` - `RouterToolSelector` trait, `LLMToolSelector` impl\n- `crates/goose/src/agents/router_tools.rs` - `router__llm_search` tool definition, prompt function\n- `crates/goose/src/agents/tool_router_index_manager.rs` - Tool indexing on extension add/remove\n\n### Integration Points\n- `crates/goose/src/agents/agent.rs` - `dispatch_tool_call()` routes `ROUTER_LLM_SEARCH_TOOL_NAME`\n- `crates/goose/src/agents/prompt_manager.rs` - `with_router_enabled()`, injects prompt\n- `crates/goose-server/src/routes/agent.rs` - `/agent/update_router_tool_selector` endpoint\n\n### UI\n- `ui/desktop/src/components/settings/tool_selection_strategy/ToolSelectionStrategySection.tsx` - Settings toggle\n\n### Prompts\n- `crates/goose/src/prompts/router_tool_selector.md` - LLM search prompt template\n- `crates/goose/src/prompts/system.md` - `{{tool_selection_strategy}}` placeholder\n\n## Key Design Patterns\n\n1. **Two-stage LLM calls**: Main LLM calls search tool \u2192 Search LLM finds relevant tools \u2192 Main LLM uses them\n2. **Extension-based indexing**: Tools indexed by extension name for filtered searches\n3. **Recently used caching**: Last 20 tool calls automatically included (no search needed)\n4. **Override mechanism**: Recipes can disable router to get all tools\n5. **Lazy initialization**: Selector only created when enabled AND provider available\n\n## Limitations Noted in UI\n\n- "Only tested with Claude models currently" (from UI description)\n- Experimental/preview feature\n\n## Open Questions\n\n1. **Performance**: What\'s the latency impact of the secondary LLM call for tool search?\n2. **Accuracy**: How well does the search LLM match tools to queries in practice?\n3. **Token savings**: What\'s the actual context window savings for typical extension counts?\n4. **Model compatibility**: Why only tested with Claude? What breaks with other models?\n',l='# Remove Tool Selection Strategy Feature - Implementation Plan\n\n## Overview\nComplete removal of the "Tool Selection Strategy" feature (also known as "LLM Tool Router" or "Smart Tool Routing"). This experimental feature used a secondary LLM call to dynamically select which tools to present to the main LLM based on the user\'s query.\n\n## Current State Analysis\nThe feature is controlled by `GOOSE_ENABLE_ROUTER` config parameter (default: false). It consists of:\n- Core implementation files (4 Rust modules + 1 prompt template)\n- Integration points in agent, prompt manager, and server routes\n- UI settings section in desktop app\n- CLI configuration dialog\n- Documentation pages\n\n### Key Discoveries:\n- Feature is disabled by default and marked as "experimental/preview"\n- Only tested with Claude models\n- Has telemetry tracking in posthog\n- Snapshot tests in `prompt_manager.rs` use `.with_router_enabled(true)` and will need updating\n- `agent.rs` test references `tool_route_manager` but only for context setup, not testing router functionality\n\n## Desired End State\n- All Tool Selection Strategy code removed from codebase\n- No `GOOSE_ENABLE_ROUTER` config handling (ignored if present in user config)\n- No `router__llm_search` tool\n- No `/agent/update_router_tool_selector` API endpoint\n- No UI settings for tool selection strategy\n- No CLI configuration for router strategy\n- Documentation removed/updated\n- All tests pass, linting passes\n\n## What We\'re NOT Doing\n- Cleaning up existing `GOOSE_ENABLE_ROUTER` entries from user config files (will be ignored)\n- Adding deprecation warnings\n- Keeping any stub code\n\n## Implementation Approach\nRemove in dependency order: core files first, then integration points, then UI/CLI, then documentation. This minimizes compilation errors during the process.\n\n---\n\n## Phase 1: Remove Core Implementation Files\n\n### Overview\nDelete the core Rust modules that implement the router functionality.\n\n### Changes Required:\n\n#### 1. Delete core router files\n**Files to delete:**\n- `crates/goose/src/agents/router_tool_selector.rs`\n- `crates/goose/src/agents/router_tools.rs`\n- `crates/goose/src/agents/tool_route_manager.rs`\n- `crates/goose/src/agents/tool_router_index_manager.rs`\n- `crates/goose/src/prompts/router_tool_selector.md`\n\n#### 2. Update module declarations\n**File**: `crates/goose/src/agents/mod.rs`\n**Changes**: Remove module declarations for deleted files\n\n```rust\n// REMOVE these lines:\nmod router_tool_selector;\nmod router_tools;\nmod tool_route_manager;\nmod tool_router_index_manager;\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] Files deleted\n- [x] `cargo build -p goose` compiles (will fail until Phase 2 completes)\n\n**Implementation Note**: Phase 1 will cause compilation errors. Proceed immediately to Phase 2.\n\n---\n\n## Phase 2: Update Agent Integration\n\n### Overview\nRemove all router-related code from `agent.rs` and related files.\n\n### Changes Required:\n\n#### 1. Update agent.rs\n**File**: `crates/goose/src/agents/agent.rs`\n**Changes**:\n\nRemove imports:\n```rust\n// REMOVE:\nuse crate::agents::router_tools::ROUTER_LLM_SEARCH_TOOL_NAME;\nuse crate::agents::tool_route_manager::ToolRouteManager;\nuse crate::agents::tool_router_index_manager::ToolRouterIndexManager;\n```\n\nRemove from Agent struct:\n```rust\n// REMOVE field:\npub tool_route_manager: Arc<ToolRouteManager>,\n```\n\nRemove from Agent::new():\n```rust\n// REMOVE:\ntool_route_manager: Arc::new(ToolRouteManager::new()),\n```\n\nRemove method `disable_router_for_recipe`:\n```rust\n// REMOVE entire method:\npub async fn disable_router_for_recipe(&self) {\n    self.tool_route_manager.disable_router_for_recipe().await;\n}\n```\n\nRemove from `dispatch_tool_call` - the `ROUTER_LLM_SEARCH_TOOL_NAME` branch:\n```rust\n// REMOVE this else-if branch:\n} else if tool_call.name == ROUTER_LLM_SEARCH_TOOL_NAME {\n    match self\n        .tool_route_manager\n        .dispatch_route_search_tool(tool_call.arguments.unwrap_or_default())\n        .await\n    {\n        Ok(tool_result) => tool_result,\n        Err(e) => return (request_id, Err(e)),\n    }\n}\n```\n\nRemove from `add_extension` - the router indexing logic:\n```rust\n// REMOVE this block:\n// If LLM tool selection is functional, index the tools\nif self.tool_route_manager.is_router_functional().await {\n    let selector = self.tool_route_manager.get_router_tool_selector().await;\n    if let Some(selector) = selector {\n        let selector = Arc::new(selector);\n        if let Err(e) = ToolRouterIndexManager::update_extension_tools(\n            &selector,\n            &self.extension_manager,\n            &extension.name(),\n            "add",\n        )\n        .await\n        {\n            return Err(ExtensionError::SetupError(format!(\n                "Failed to index tools for extension {}: {}",\n                extension.name(),\n                e\n            )));\n        }\n    }\n}\n```\n\nRemove `list_tools_for_router` method:\n```rust\n// REMOVE entire method:\npub async fn list_tools_for_router(&self) -> Vec<Tool> {\n    ...\n}\n```\n\nRemove from `remove_extension` - the router de-indexing logic:\n```rust\n// REMOVE this block:\n// If LLM tool selection is functional, remove tools from the index\nif self.tool_route_manager.is_router_functional().await {\n    let selector = self.tool_route_manager.get_router_tool_selector().await;\n    if let Some(selector) = selector {\n        ToolRouterIndexManager::update_extension_tools(\n            &selector,\n            &self.extension_manager,\n            name,\n            "remove",\n        )\n        .await?;\n    }\n}\n```\n\nRemove `update_router_tool_selector` method:\n```rust\n// REMOVE entire method:\npub async fn update_router_tool_selector(\n    &self,\n    provider: Option<Arc<dyn Provider>>,\n    reindex_all: Option<bool>,\n) -> Result<()> {\n    ...\n}\n```\n\nRemove from `reply_internal` stream - the `record_tool_requests` call:\n```rust\n// REMOVE:\nself.tool_route_manager\n    .record_tool_requests(&requests_to_record)\n    .await;\n```\n\n#### 2. Update extension.rs (PlatformExtensionContext)\n**File**: `crates/goose/src/agents/extension.rs`\n**Changes**: Remove `tool_route_manager` field from `PlatformExtensionContext` if present\n\nSearch for any references to `tool_route_manager` in this file and remove them.\n\n#### 3. Update extension_manager_extension.rs\n**File**: `crates/goose/src/agents/extension_manager_extension.rs`\n**Changes**: Remove any references to `tool_route_manager`\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] `cargo build -p goose` compiles (may still fail until Phase 3)\n\n---\n\n## Phase 3: Update Prompt Manager\n\n### Overview\nRemove router-related prompt building logic.\n\n### Changes Required:\n\n#### 1. Update prompt_manager.rs\n**File**: `crates/goose/src/agents/prompt_manager.rs`\n**Changes**:\n\nRemove import:\n```rust\n// REMOVE:\nuse crate::agents::router_tools::llm_search_tool_prompt;\n```\n\nRemove from `SystemPromptContext`:\n```rust\n// REMOVE field:\n#[serde(skip_serializing_if = "Option::is_none")]\ntool_selection_strategy: Option<String>,\n```\n\nRemove from `SystemPromptBuilder`:\n```rust\n// REMOVE field:\nrouter_enabled: bool,\n```\n\nRemove `with_router_enabled` method:\n```rust\n// REMOVE entire method:\npub fn with_router_enabled(mut self, enabled: bool) -> Self {\n    self.router_enabled = enabled;\n    self\n}\n```\n\nUpdate `build` method - remove router_enabled from context:\n```rust\n// REMOVE from SystemPromptContext construction:\ntool_selection_strategy: self.router_enabled.then(llm_search_tool_prompt),\n```\n\nUpdate builder initialization:\n```rust\n// REMOVE from SystemPromptBuilder initialization:\nrouter_enabled: false,\n```\n\n#### 2. Update system.md template\n**File**: `crates/goose/src/prompts/system.md`\n**Changes**: Remove the `{{tool_selection_strategy}}` placeholder line\n\n```markdown\n\x3c!-- REMOVE this line: --\x3e\n{{tool_selection_strategy}}\n```\n\n#### 3. Update snapshot tests\n**File**: `crates/goose/src/agents/prompt_manager.rs` (tests section)\n**Changes**: Remove `.with_router_enabled(true)` from tests\n\nIn `test_one_extension`:\n```rust\n// REMOVE:\n.with_router_enabled(true)\n```\n\nIn `test_typical_setup`:\n```rust\n// REMOVE:\n.with_router_enabled(true)\n```\n\n#### 4. Update/regenerate snapshots\n**Files to update:**\n- `crates/goose/src/agents/snapshots/goose__agents__prompt_manager__tests__one_extension.snap`\n- `crates/goose/src/agents/snapshots/goose__agents__prompt_manager__tests__typical_setup.snap`\n\nRun `cargo test -p goose prompt_manager` with `INSTA_UPDATE=1` to regenerate snapshots, or manually remove the "LLM Tool Selection Instructions" section from each snapshot.\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] `cargo build -p goose` compiles\n- [x] `cargo test -p goose` passes (after snapshot updates)\n\n---\n\n## Phase 4: Update Server Routes\n\n### Overview\nRemove the `/agent/update_router_tool_selector` endpoint.\n\n### Changes Required:\n\n#### 1. Update agent.rs routes\n**File**: `crates/goose-server/src/routes/agent.rs`\n**Changes**:\n\nRemove request struct:\n```rust\n// REMOVE:\n#[derive(Deserialize, utoipa::ToSchema)]\npub struct UpdateRouterToolSelectorRequest {\n    session_id: String,\n}\n```\n\nRemove handler function:\n```rust\n// REMOVE entire function:\n#[utoipa::path(\n    post,\n    path = "/agent/update_router_tool_selector",\n    ...\n)]\nasync fn update_router_tool_selector(\n    ...\n) -> Result<Json<String>, StatusCode> {\n    ...\n}\n```\n\nRemove route from router:\n```rust\n// REMOVE from routes() function:\n.route(\n    "/agent/update_router_tool_selector",\n    post(update_router_tool_selector),\n)\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] `cargo build -p goose-server` compiles\n- [x] `cargo test -p goose-server` passes\n\n---\n\n## Phase 5: Update CLI Configuration\n\n### Overview\nRemove the router configuration dialog from CLI.\n\n### Changes Required:\n\n#### 1. Update configure.rs\n**File**: `crates/goose-cli/src/commands/configure.rs`\n**Changes**:\n\nRemove the router strategy menu item from `configure_settings_dialog`:\n```rust\n// REMOVE this item:\n.item(\n    "goose_router_strategy",\n    "Router Tool Selection Strategy",\n    "Experimental: configure a strategy for auto selecting tools to use",\n)\n```\n\nRemove the match arm:\n```rust\n// REMOVE:\n"goose_router_strategy" => {\n    configure_goose_router_strategy_dialog()?;\n}\n```\n\nRemove the entire `configure_goose_router_strategy_dialog` function:\n```rust\n// REMOVE entire function:\npub fn configure_goose_router_strategy_dialog() -> anyhow::Result<()> {\n    ...\n}\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] `cargo build -p goose-cli` compiles\n- [x] `cargo test -p goose-cli` passes\n\n---\n\n## Phase 6: Update Telemetry \u2705 COMPLETE\n\n### Overview\nRemove router-related telemetry.\n\n### Changes Required:\n\n#### 1. Update posthog.rs\n**File**: `crates/goose/src/posthog.rs`\n**Changes**:\n\nRemove the router telemetry:\n```rust\n// REMOVE this block:\nif let Ok(router_enabled) = config.get_param::<bool>("GOOSE_ENABLE_ROUTER") {\n    event\n        .insert_prop("setting_router_enabled", router_enabled)\n        .ok();\n}\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] `cargo build -p goose` compiles\n\n---\n\n## Phase 7: Update Desktop UI \u2705 COMPLETE\n\n### Overview\nRemove the Tool Selection Strategy settings section from the desktop app.\n\n### Changes Required:\n\n#### 1. Delete UI component directory\n**Directory to delete**: `ui/desktop/src/components/settings/tool_selection_strategy/`\n\n#### 2. Update ChatSettingsSection.tsx\n**File**: `ui/desktop/src/components/settings/chat/ChatSettingsSection.tsx`\n**Changes**:\n\nRemove import:\n```typescript\n// REMOVE:\nimport { ToolSelectionStrategySection } from \'../tool_selection_strategy/ToolSelectionStrategySection\';\n```\n\nRemove the Card containing ToolSelectionStrategySection:\n```tsx\n{/* REMOVE entire Card: */}\n<Card className="pb-2 rounded-lg">\n  <CardHeader className="pb-0">\n    <CardTitle className="">Tool Selection Strategy (preview)</CardTitle>\n    <CardDescription>\n      Experimental: configure how Goose selects tools for your requests, useful when there are\n      many tools. Only tested with Claude models currently.\n    </CardDescription>\n  </CardHeader>\n  <CardContent className="px-2">\n    <ToolSelectionStrategySection />\n  </CardContent>\n</Card>\n```\n\n#### 3. Regenerate OpenAPI types\nRun: `just generate-openapi`\n\nThis will update `ui/desktop/openapi.json` and `ui/desktop/src/api/types.gen.ts` to remove the `UpdateRouterToolSelectorRequest` type.\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] `cd ui/desktop && npm run lint` passes\n- [x] `cd ui/desktop && npm run typecheck` passes\n- [x] OpenAPI types regenerated\n\n#### Manual Verification:\n- [ ] Desktop app Settings > Chat page loads without errors\n- [ ] No "Tool Selection Strategy" section visible\n\n---\n\n## Phase 8: Update Documentation \u2705 COMPLETE\n\n### Overview\nRemove documentation for the removed feature.\n\n### Changes Required:\n\n#### 1. Delete tool-router.md\n**File to delete**: `documentation/docs/guides/managing-tools/tool-router.md`\n\n#### 2. Update managing-tools index\n**File**: `documentation/docs/guides/managing-tools/index.md`\n**Changes**:\n\nRemove the Tool Selection Strategy card:\n```tsx\n{/* REMOVE: */}\n<Card \n  title="Tool Selection Strategy"\n  description="Optimize tool selection with dynamic routing that loads only the tools you need, reducing context overhead and improving performance."\n  link="/docs/guides/managing-tools/tool-router"\n/>\n```\n\n#### 3. Update environment-variables.md\n**File**: `documentation/docs/guides/environment-variables.md`\n**Changes**:\n\nRemove the `GOOSE_ENABLE_ROUTER` row from the table:\n```markdown\n\x3c!-- REMOVE this row: --\x3e\n| `GOOSE_ENABLE_ROUTER` | Enables [intelligent tool selection strategy](/docs/guides/managing-tools/tool-router) | "true", "false" | "false" |\n```\n\nRemove from the example section:\n```bash\n# REMOVE:\n# Enable intelligent tool selection\nexport GOOSE_ENABLE_ROUTER=true\n```\n\n#### 4. Check for other documentation references\nSearch for any other references to "tool selection", "router", or "GOOSE_ENABLE_ROUTER" in documentation and remove them.\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] No remaining references to GOOSE_ENABLE_ROUTER in documentation\n\n#### Manual Verification:\n- [ ] No references to Tool Selection Strategy in docs\n\n---\n\n## Phase 9: Update Tests \u2705 COMPLETE (merged into earlier phases)\n\n### Overview\nUpdate any remaining tests that reference the removed functionality.\n\n### Changes Required:\n\n#### 1. Update agent.rs tests\n**File**: `crates/goose/tests/agent.rs`\n**Changes**:\n\nIn `extension_manager_tests::setup_agent_with_extension_manager`, remove the `tool_route_manager` from context setup:\n```rust\n// REMOVE from PlatformExtensionContext:\ntool_route_manager: Some(Arc::downgrade(&agent.tool_route_manager)),\n```\n\n#### 2. Update PlatformExtensionContext references\nSearch for any other test files that set up `PlatformExtensionContext` with `tool_route_manager` and remove that field.\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] `cargo test` passes for all crates\n- [x] `./scripts/clippy-lint.sh` passes\n\n---\n\n## Phase 10: Final Cleanup and Verification \u2705 COMPLETE\n\n### Overview\nFinal verification that all changes are complete and correct.\n\n### Changes Required:\n\n#### 1. Search for any remaining references\nRun these searches to ensure nothing was missed:\n```bash\nrg "tool_route" --type rust\nrg "router_tool" --type rust\nrg "RouterToolSelector" --type rust\nrg "ROUTER_LLM_SEARCH" --type rust\nrg "llm_search_tool" --type rust\nrg "GOOSE_ENABLE_ROUTER" --type rust\nrg "tool_selection_strategy" --type rust\nrg "ToolSelectionStrategy" --type ts --type tsx\n```\n\n#### 2. Run full test suite\n```bash\ncargo fmt\ncargo build\ncargo test\n./scripts/clippy-lint.sh\n```\n\n#### 3. Run UI checks\n```bash\ncd ui/desktop\nnpm run lint\nnpm run build\nnpm test\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [x] All searches return no results (except in thoughts/research)\n- [x] `cargo fmt` - no changes\n- [x] `cargo build` - succeeds\n- [x] `cargo test` - all tests pass\n- [x] `./scripts/clippy-lint.sh` - passes\n- [x] UI lint/typecheck - passes\n\n#### Manual Verification:\n- [ ] Start goose CLI - works normally\n- [ ] Start goose desktop - works normally\n- [ ] Settings page loads without errors\n- [ ] No console errors related to removed feature\n\n---\n\n## Testing Strategy\n\n### Unit Tests:\n- Snapshot tests in `prompt_manager.rs` need regeneration (Phase 3)\n- Agent tests need `tool_route_manager` references removed (Phase 9)\n\n### Integration Tests:\n- Full `cargo test` after all phases\n- Desktop app manual testing after Phase 7\n\n### Regression Testing:\n- Ensure normal tool calling still works\n- Ensure extension add/remove still works\n- Ensure all goose modes (auto, approve, smart_approve, chat) still work\n\n---\n\n## Rollback Plan\nIf issues are discovered:\n1. Git revert the changes\n2. The feature was disabled by default, so no user impact from keeping it\n\n---\n\n## Notes\n- The research document at `thoughts/research/2025-12-22-llm-tool-selection-strategy.md` should be kept for historical reference\n- Users with `GOOSE_ENABLE_ROUTER=true` in their config will simply have the setting ignored\n',c={title:"Research \u2192 Plan \u2192 Implement Pattern",description:"How to use RPI, a context engineering technique, on complex software projects"},d=void 0,u={},h=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"RPI Workflow",id:"rpi-workflow",level:2},{value:"The Task",id:"the-task",level:2},{value:"Session 1: Research",id:"session-1-research",level:2},{value:"Session 2: Plan",id:"session-2-plan",level:2},{value:"Session 3: Implement",id:"session-3-implement",level:2},{value:"Final Result",id:"final-result",level:2},{value:"When to Use RPI",id:"when-to-use-rpi",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:'Most people use AI agents by jumping straight to execution: "refactor this code", "remove this feature", "add this new feature". While sometimes this works well, especially for smaller changes or codebases, it often falls apart on complex changes.'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://github.com/humanlayer/advanced-context-engineering-for-coding-agents/blob/main/ace-fca.md",children:"RPI (Research, Plan, Implement)"})}),", introduced by HumanLayer, proposes a different way of working with AI agents. This approach trades speed for clarity, predictability, and correctness."]}),"\n",(0,s.jsx)(n.p,{children:"This tutorial walks through how RPI works via a real demonstration. By the end, you should be able to run this same workflow on your own codebase."}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"1. Import RPI Recipes"}),(0,s.jsx)(n.p,{children:"Copy the snippet below and paste it in your terminal. This will download the main RPI recipes and their subrecipes and save them into the global recipe directory."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"mkdir -p ~/.config/goose/recipes/subrecipes\n\ncurl -sL https://raw.githubusercontent.com/block/goose/main/documentation/src/pages/recipes/data/recipes/rpi-research.yaml -o ~/.config/goose/recipes/rpi-research.yaml\ncurl -sL https://raw.githubusercontent.com/block/goose/main/documentation/src/pages/recipes/data/recipes/rpi-plan.yaml -o ~/.config/goose/recipes/rpi-plan.yaml\ncurl -sL https://raw.githubusercontent.com/block/goose/main/documentation/src/pages/recipes/data/recipes/rpi-implement.yaml -o ~/.config/goose/recipes/rpi-implement.yaml\ncurl -sL https://raw.githubusercontent.com/block/goose/main/documentation/src/pages/recipes/data/recipes/rpi-iterate.yaml -o ~/.config/goose/recipes/rpi-iterate.yaml\n\ncurl -sL https://raw.githubusercontent.com/block/goose/main/documentation/src/pages/recipes/data/recipes/subrecipes/rpi-codebase-locator.yaml -o ~/.config/goose/recipes/subrecipes/rpi-codebase-locator.yaml\ncurl -sL https://raw.githubusercontent.com/block/goose/main/documentation/src/pages/recipes/data/recipes/subrecipes/rpi-codebase-analyzer.yaml -o ~/.config/goose/recipes/subrecipes/rpi-codebase-analyzer.yaml\ncurl -sL https://raw.githubusercontent.com/block/goose/main/documentation/src/pages/recipes/data/recipes/subrecipes/rpi-pattern-finder.yaml -o ~/.config/goose/recipes/subrecipes/rpi-pattern-finder.yaml\n"})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"2. Add Custom Slash Commands"}),(0,s.jsxs)(n.p,{children:["Now that the recipes are imported, to quickly invoke them in-session ",(0,s.jsx)(n.a,{href:"/docs/guides/context-engineering/slash-commands",children:"add custom slash commands"})," for each of the following recipes:"]}),(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Recipe"}),(0,s.jsx)(n.th,{children:"Slash Command"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"RPI Research Codebase"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"research"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"RPI Create Plan"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"plan"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"RPI Implement Plan"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"implement"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"RPI Iterate"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"iterate"})})]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"rpi-workflow",children:"RPI Workflow"}),"\n",(0,s.jsx)(n.p,{children:"In goose, we use a structured RPI workflow using recipes to systematically tackle complex codebase changes. The workflow consists of slash commands that guide goose through disciplined phases of work:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"research"})," \u2013 Document what exists today. No opinions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"plan"})," - Design the change with clear phases and success criteria."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"implement"})," - Execute the plan step by step with verification."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"iterate"})," \u2013 (optional) Adjust the plan if necessary."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-md",children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500-\u2510\n\u2502                           RPI WORKFLOW                                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500-\u2524\n\u2502                                                                              \u2502\n\u2502  /research "topic"                                                           \u2502\n\u2502       \u2502                                                                      \u2502\n\u2502       \u251c\u2500\u2500\u25ba Spawns parallel sub-agents:                                       \u2502\n\u2502       \u2502    \u2022 find_files (rpi-codebase-locator)                               \u2502\n\u2502       \u2502    \u2022 analyze_code (rpi-codebase-analyzer)                            \u2502\n\u2502       \u2502    \u2022 find_patterns (rpi-pattern-finder)                              \u2502\n\u2502       \u2502                                                                      \u2502\n\u2502       \u2514\u2500\u2500\u25ba Output: thoughts/research/YYYY-MM-DD-HHmm-topic.md                \u2502\n\u2502                                                                              \u2502\n\u2502  /plan "feature/task"                                                        \u2502\n\u2502       \u2502                                                                      \u2502\n\u2502       \u251c\u2500\u2500\u25ba Reads research docs                                               \u2502\n\u2502       \u251c\u2500\u2500\u25ba Asks clarifying questions                                         \u2502\n\u2502       \u251c\u2500\u2500\u25ba Proposes design options                                           \u2502\n\u2502       \u2502                                                                      \u2502\n\u2502       \u2514\u2500\u2500\u25ba Output: thoughts/plans/YYYY-MM-DD-HHmm-description.md             \u2502\n\u2502                                                                              \u2502\n\u2502  /implement "plan path"                                                      \u2502\n\u2502       \u2502                                                                      \u2502\n\u2502       \u251c\u2500\u2500\u25ba Executes phase by phase                                           \u2502\n\u2502       \u251c\u2500\u2500\u25ba Runs verification after each phase                                \u2502\n\u2502       \u251c\u2500\u2500\u25ba Updates checkboxes in plan                                        \u2502\n\u2502       \u2502                                                                      \u2502\n\u2502       \u2514\u2500\u2500\u25ba Working code                                                      \u2502\n\u2502                                                                              \u2502\n\u2502  /iterate "plan path" + feedback                                             \u2502\n\u2502       \u2502                                                                      \u2502\n\u2502       \u251c\u2500\u2500\u25ba Researches only what changed                                      \u2502\n\u2502       \u251c\u2500\u2500\u25ba Updates the plan surgically                                       \u2502\n\u2502       \u2502                                                                      \u2502\n\u2502       \u2514\u2500\u2500\u25ba Updated plan                                                      \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500-\u2518\n'})}),"\n",(0,s.jsx)(n.p,{children:"All RPI outputs live in a predictable place:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-md",children:"thoughts/\n\u251c\u2500\u2500 research/\n\u2502   \u2514\u2500\u2500 YYYY-MM-DD-HHmm-topic.md\n\u2514\u2500\u2500 plans/\n    \u2514\u2500\u2500 YYYY-MM-DD-HHmm-description.md\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-task",children:"The Task"}),"\n",(0,s.jsx)(n.p,{children:"In this tutorial, I want to remove an existing feature from a large codebase."}),"\n",(0,s.jsx)(n.p,{children:"This isn't a small change. The feature touches:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Core Rust code"}),"\n",(0,s.jsx)(n.li,{children:"TypeScript"}),"\n",(0,s.jsx)(n.li,{children:"Configuration"}),"\n",(0,s.jsx)(n.li,{children:"Tests"}),"\n",(0,s.jsx)(n.li,{children:"Documentation"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'This is the kind of task where agents often struggle, not because they\'re incapable, but because the work spans too much context to safely "just do it."'}),"\n",(0,s.jsx)(n.p,{children:"So instead of jumping to implementation, we'll use RPI."}),"\n",(0,s.jsx)(n.h2,{id:"session-1-research",children:"Session 1: Research"}),"\n",(0,s.jsx)(n.p,{children:"The concept of planning before implementation has become a widely accepted practice. However, planning without research can lead to assumptions that come back to bite you. So, in RPI, we begin with research."}),"\n",(0,s.jsxs)(n.p,{children:["I start the prompt with the ",(0,s.jsx)(n.code,{children:"/research"})," command followed by a topic written in natural language"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'/research "look through the cloned goose repo and research how the LLM Tool Discovery is implemented"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This command invokes the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://raw.githubusercontent.com/block/goose/refs/heads/main/documentation/src/pages/recipes/data/recipes/rpi-research.yaml",children:"RPI Research Codebase"})})," recipe, whose job is very strict:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Document what exists"}),"\n",(0,s.jsx)(n.li,{children:"Do not suggest changes"}),"\n",(0,s.jsx)(n.li,{children:"Do not critique"}),"\n",(0,s.jsx)(n.li,{children:"Do not plan"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"With this recipe, goose automatically spawns three parallel subagents:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"find_files"}),": Uses the codebase locator to figure out where relevant files live."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"analyze_code"}),": Reads those files fully and documents how they work."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"find_patterns"}),": Looks for similar features or conventions elsewhere in the repo."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These subagents run independently and report back. You don't have to orchestrate that yourself."}),"\n",(0,s.jsxs)(n.admonition,{title:"A course correction",type:"info",children:[(0,s.jsx)(n.p,{children:'After goose began researching, I noticed that it was researching "tool discovery" in general. But I only wanted to remove a specific feature called Tool Selection Strategy. So I stopped goose and reran research with a more accurate topic.'}),(0,s.jsx)(n.p,{children:'That wasn\'t a failure. In fact, this is exactly why research exists. Had I told goose to "remove the LLM Tool Discovery feature", it may have removed our other tool discovery methods as well. Fortunately, catching these types of mistakes early is cheap and easy to recover from.'})]}),"\n",(0,s.jsxs)(n.p,{children:["The output from the ",(0,s.jsx)(n.code,{children:"/research"})," session was a detailed research document:"]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"./thoughts/research/2025-12-22-llm-tool-selection-strategy.md"}),(0,s.jsx)(a.A,{language:"markdown",children:i})]}),"\n",(0,s.jsx)(n.p,{children:"This is a large, structured file that includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Git metadata"}),"\n",(0,s.jsx)(n.li,{children:"File and line references"}),"\n",(0,s.jsx)(n.li,{children:"Flow descriptions"}),"\n",(0,s.jsx)(n.li,{children:"Key components"}),"\n",(0,s.jsx)(n.li,{children:"Open questions"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Think of it as a technical map of the feature as it exists today. Nothing was changed yet, and that's intentional. The only goal was shared understanding."}),"\n",(0,s.jsx)(n.p,{children:"As the human in the loop, be sure to review the research! This will inform the plan, so you want to make sure this is accurate."}),"\n",(0,s.jsx)(n.h2,{id:"session-2-plan",children:"Session 2: Plan"}),"\n",(0,s.jsx)(n.p,{children:"Once research is complete, you move to planning."}),"\n",(0,s.jsx)(n.admonition,{title:"Sessions",type:"tip",children:(0,s.jsx)(n.p,{children:"It's important to do each phase in a new session to keep the LLM laser focused on only the task at hand. One goal per session!"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"/plan a removal of the Tool Selection Strategy feature\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://raw.githubusercontent.com/block/goose/refs/heads/main/documentation/src/pages/recipes/data/recipes/rpi-plan.yaml",children:"RPI Create Plan"})})," recipe starts by reading the research document goose created."]}),"\n",(0,s.jsx)(n.p,{children:"Then it did three key things:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Asked clarifying questions\nFor example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Full removal vs deprecation?"}),"\n",(0,s.jsx)(n.li,{children:"How should config cleanup behave?"}),"\n",(0,s.jsx)(n.li,{children:"Should OpenAPI artifacts be regenerated?"}),"\n",(0,s.jsx)(n.li,{children:"Where do related tests live?"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Presented design options\nWhere there were multiple reasonable approaches, goose laid them out and asked me to choose."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Produced a phased implementation plan"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The output was a detailed plan:"}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"thoughts/plans/2025-12-23-remove-tool-selection-strategy.md"}),(0,s.jsx)(a.A,{language:"markdown",children:l})]}),"\n",(0,s.jsx)(n.p,{children:"This plan includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"10 explicit phases"}),"\n",(0,s.jsx)(n.li,{children:"Exact file paths"}),"\n",(0,s.jsx)(n.li,{children:"Code snippets showing what to remove"}),"\n",(0,s.jsx)(n.li,{children:"Automated success criteria"}),"\n",(0,s.jsx)(n.li,{children:"Manual verification steps"}),"\n",(0,s.jsx)(n.li,{children:"Checkboxes for tracking progress"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"At this point, the plan became the source of truth. The key shift here is that we've moved from understanding to decision making, but we're still not touching code."}),"\n",(0,s.jsx)(n.p,{children:"The plan is explicit enough that someone else could execute it. That's not an accident. Remember that the implementation will be in a fresh new session, so the plan must have enough context to actually execute it."}),"\n",(0,s.jsxs)(n.p,{children:["Again, you as the human need to step in here to review the plan and make sure it's solid. If there's anything amiss, instead of starting over you can run the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://raw.githubusercontent.com/block/goose/refs/heads/main/documentation/src/pages/recipes/data/recipes/rpi-iterate.yaml",children:"RPI Iterate Plan"})})," plan (",(0,s.jsx)(n.code,{children:"/iterate"}),") with details on what's wrong. goose will then read the existing plan, research only what needs rethinking, propose targeted updates, and edit the plan accordingly."]}),"\n",(0,s.jsx)(n.h2,{id:"session-3-implement",children:"Session 3: Implement"}),"\n",(0,s.jsx)(n.p,{children:"Only after research and planning are complete should you move to implementation. Pass in the plan document."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"/implement thoughts/plans/2025-12-23-remove-tool-selection-strategy.md\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://raw.githubusercontent.com/block/goose/refs/heads/main/documentation/src/pages/recipes/data/recipes/rpi-implement.yaml",children:"RPI Implement Plan"})})," recipe is intentionally boring. In fact, I fell asleep while goose was running it. Implementation should feel mechanical. If it feels creative, something upstream is missing. But knowing that you have a rock solid plan, I advise you to go do something else with your time while goose works (unless there are manual steps in the plan)."]}),"\n",(0,s.jsx)(n.p,{children:"It will read the plan completely, execute the phases in order, run verification after each phase, and update the checkboxes directly in the plan file as it goes."}),"\n",(0,s.jsx)(n.p,{children:"That last bit was really helpful because my context window filled up partway through and goose was able to compact and pick up right where it left off because of the status updates in the plan."}),"\n",(0,s.jsx)(n.h2,{id:"final-result",children:"Final Result"}),"\n",(0,s.jsx)(n.p,{children:"For 10 phases of work that spanned 32 files, the Research phase took 9 minutes, the Plan phase took 4 minutes, and the Implement phase took 39 minutes. So in total, this took just shy of an hour... 52 minutes to be exact. This included goose working and testing as well as me answering questions."}),"\n",(0,s.jsxs)(n.p,{children:["Definitely not a fast process. BUT! When I put up ",(0,s.jsx)(n.a,{href:"https://github.com/block/goose/pull/6250",children:"this PR"}),", the build passed and the separate Code Review Agent didn't have a single comment. That's just how well done the work was."]}),"\n",(0,s.jsx)(n.p,{children:"Had I done this without AI, it would have likely taken me several hours of work as the feature was complex and deeply integrated. And had I had AI jump straight to implementation, I have no doubt it would have surely drifted and messed something up."}),"\n",(0,s.jsx)(n.p,{children:"So while RPI is slower than having AI get right to work, the quality is top notch. A very worthy tradeoff."}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-rpi",children:"When to Use RPI"}),"\n",(0,s.jsx)(n.p,{children:"For basic tasks, RPI may be overkill. Especially because it's not a quick process. However, if you need to do a complex task that spans multiple files, it's a great choice."}),"\n",(0,s.jsx)(n.p,{children:"You can use RPI for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Refactors"}),"\n",(0,s.jsx)(n.li,{children:"Migrations"}),"\n",(0,s.jsx)(n.li,{children:"Feature additions"}),"\n",(0,s.jsx)(n.li,{children:"Large upgrades"}),"\n",(0,s.jsx)(n.li,{children:"Incident cleanup"}),"\n",(0,s.jsx)(n.li,{children:"Documentation overhauls"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Try it for yourself!"})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);