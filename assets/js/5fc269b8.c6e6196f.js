"use strict";(globalThis.webpackChunkgoose=globalThis.webpackChunkgoose||[]).push([[4088],{14627:e=>{e.exports=JSON.parse('{"permalink":"/goose/blog/2025/10/24/intro-to-agent-client-protocol-acp","source":"@site/blog/2025-10-24-intro-to-agent-client-protocol-acp/index.md","title":"Intro to Agent Client Protocol (ACP): The Standard for AI Agent-Editor Integration","description":"Fix the awkward gap between AI agents and code editors with the Agent Client Protocol (ACP). Learn why this new open standard makes agents like goose truly editor-agnostic, improving AI-human collaboration and restoring developer flow state. ACP works alongside protocols like MCP to create an open AI tooling ecosystem.","date":"2025-10-24T00:00:00.000Z","tags":[],"readingTime":6.51,"hasTruncateMarker":true,"authors":[{"name":"Rizel Scarlett","title":"Staff Developer Advocate","page":{"permalink":"/goose/blog/authors/rizel"},"socials":{"x":"https://x.com/blackgirlbytes","github":"https://github.com/blackgirlbytes","bluesky":"https://bsky.app/profile/blackgirlbytes.bsky.social","linkedin":"https://www.linkedin.com/in/rizel-bobb-semple/"},"imageURL":"https://avatars.githubusercontent.com/u/22990146?v=4","key":"rizel"}],"frontMatter":{"title":"Intro to Agent Client Protocol (ACP): The Standard for AI Agent-Editor Integration","description":"Fix the awkward gap between AI agents and code editors with the Agent Client Protocol (ACP). Learn why this new open standard makes agents like goose truly editor-agnostic, improving AI-human collaboration and restoring developer flow state. ACP works alongside protocols like MCP to create an open AI tooling ecosystem.","authors":["rizel"]},"unlisted":false,"prevItem":{"title":"How to Successfully Migrate Your App with an AI Agent","permalink":"/goose/blog/2025/11/17/migrate-app-with-ai-agent"},"nextItem":{"title":"Designing AI for Users, Not Just LLMs","permalink":"/goose/blog/2025/10/14/designing-ai-for-humans"}}')},28453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>a});var n=o(96540);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}},58844:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});var n=o(14627),i=o(74848),s=o(28453);const r={title:"Intro to Agent Client Protocol (ACP): The Standard for AI Agent-Editor Integration",description:"Fix the awkward gap between AI agents and code editors with the Agent Client Protocol (ACP). Learn why this new open standard makes agents like goose truly editor-agnostic, improving AI-human collaboration and restoring developer flow state. ACP works alongside protocols like MCP to create an open AI tooling ecosystem.",authors:["rizel"]},a=void 0,l={authorsImageUrls:[void 0]},c=[{value:"The Three-App Problem",id:"the-three-app-problem",level:2},{value:"Common Workarounds",id:"common-workarounds",level:2},{value:"Introducing Agent Client Protocol",id:"introducing-agent-client-protocol",level:2},{value:"Restoring Developer Flow",id:"restoring-developer-flow",level:2},{value:"See ACP in Action",id:"see-acp-in-action",level:2}];function d(e){const t={a:"a",em:"em",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Head:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Choose Your IDE",src:o(85016).A+"",width:"1206",height:"633"})}),"\n",(0,i.jsx)(t.p,{children:"I code best when I sit criss-cross applesauce on my bed or couch with my laptop in my lap, a snack nearby, and no extra screens competing for my attention. Sometimes I keep the editor and browser side by side; other times, I make them full screen and switch between applications. I don't like using multiple monitors, and my developer environment is embarrassingly barebones."}),"\n",(0,i.jsx)(t.p,{children:"The described setup allows me to fall into a deep flow state, which is essential for staying productive as a software engineer. It gives me the focus to dig beneath the surface of a problem, trace its root cause, and think about how every fix or improvement affects both users and the system as a whole. While quick bursts of multitasking may work well for other fields, real productivity in engineering often comes from long stretches of uninterrupted thought."}),"\n",(0,i.jsx)(t.p,{children:"Recently, my workflow changed."}),"\n",(0,i.jsx)(t.h2,{id:"the-three-app-problem",children:"The Three-App Problem"}),"\n",(0,i.jsx)(t.p,{children:"Now that I use an AI agent regularly, I need to juggle three applications: my editor, my AI agent, and my browser to see what gets rendered. This creates several challenges that disrupt my flow:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Reduced screen real estate."})," When I try to keep all three windows visible at once in a split-screen layout, each window becomes cramped. My editor shrinks to a narrow column, making it hard to read code. The AI agent window can't display full responses without scrolling. And my browser preview gets squeezed into a tiny viewport that doesn't reflect how users will actually see the app."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"The temptation to go agent-only."})," To avoid the cramped feeling, I sometimes keep only the AI agent window open full-screen, trusting whatever it generates without switching to my editor to review the actual code changes or examine diffs. While this works fine for experimental projects, production systems require human oversight and careful code review."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Awkward context switching."})," My other approach is to keep the AI agent full-screen but actually do the responsible thing and review its work. I'll read the agent's suggestion, switch windows to my editor to see the change, switch to my browser to check what rendered, then switch back to the agent to continue refining the code through iterative prompts (what Patrick Erichsen from ",(0,i.jsx)(t.a,{href:"https://continue.dev",children:"Continue"})," calls ",(0,i.jsx)(t.a,{href:"https://patrickerichsen.com/chiseling",children:"chiseling"}),"). This constant window-switching breaks my concentration and creates opportunities for distraction (hello, Twitter/X)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"common-workarounds",children:"Common Workarounds"}),"\n",(0,i.jsx)(t.p,{children:"Many developers have tried to solve this integration challenge:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"IDE-integrated agents"})," like Cursor have an AI agent baked into the code editor. However, this creates vendor lock-in where you must use their specific agent with their specific editor. If I preferred VS Code as an editor and Claude Code as my agent, I'd be out of luck. I can't mix and match the tools I want."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"CLI agents in the terminal"})," work for some people. They run the agent directly in their editor's terminal pane. ",(0,i.jsx)(t.a,{href:"/",children:"goose"})," has a CLI I could use this way, but I prefer the desktop app's interface for readability and navigating responses. The tradeoff is the constant window-switching I was trying to avoid."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"IDE extensions and plugins"})," seem like an obvious solution, but maintaining these integrations is incredibly difficult. In the past year, multiple maintainers built VS Code extensions and even an IntelliJ plugin for goose, but our twice-weekly releases quickly made them outdated. Maintaining these extensions became a constant game of catch-up that our community couldn't win. Extensions have to mirror goose's functionality to work properly, so every change to goose requires updating the extensions. Maintainers couldn't keep pace, and building specific integrations for every editor simply doesn't scale when agents evolve at such a fast pace."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"introducing-agent-client-protocol",children:"Introducing Agent Client Protocol"}),"\n",(0,i.jsxs)(t.p,{children:["Zed Industries, the creators of the Zed code editor, developed a solution called ",(0,i.jsx)(t.a,{href:"https://agentclientprotocol.com/overview/introduction",children:"Agent Client Protocol (ACP)"})," that resolves these integration challenges. ACP allows you to bring any AI agent into any supporting editor without vendor lock-in. More importantly, it solves the maintenance problem because the AI agent and editor communicate directly through a standardized protocol."]}),"\n",(0,i.jsx)(t.p,{children:"This standardization is achieved by defining a common language via JSON-RPC. Instead of every editor and agent building private, complex handshakes, ACP uses a simple, predictable sequence of structured messages to manage the agent-editor session:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"session/initialize:"})," Your AI agent tells the editor what capabilities it supports (audio, text prompts, etc.)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"session/new:"})," When you start a new session, the agent and editor establish communication"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"session/prompt:"})," When you send a prompt, the agent receives and processes it"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"session/update:"})," The agent sends responses back to the editor"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"session/cancel:"})," When you cancel a session, the agent stops processing"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Today, editors that support ACP include Zed, Neovim, and Marimo. Supported agents include Claude Code, Codex CLI, Gemini, StackPack, and of course, goose."}),"\n",(0,i.jsx)(t.h2,{id:"restoring-developer-flow",children:"Restoring Developer Flow"}),"\n",(0,i.jsx)(t.p,{children:"For developers like me who have specific ways of achieving flow state, this means we can add AI assistance without completely restructuring our work environment. I can keep my criss-cross applesauce position, my split-screen setup, and my focused workflow while having goose integrated directly into my editor."}),"\n",(0,i.jsx)(t.p,{children:"Beyond personal workflow preferences, ACP lowers the barrier to innovation by allowing AI agents and editors to evolve independently while speaking a shared language. And it's part of a broader movement toward open standards in AI tooling."}),"\n",(0,i.jsxs)(t.p,{children:["You might have heard of ",(0,i.jsx)(t.a,{href:"http://modelcontextprotocol.io",children:"MCP"}),", which standardizes how AI agents connect to data sources and tools. ACP and MCP complement each other perfectly: MCP handles the ",(0,i.jsx)(t.em,{children:"what"})," (what data and tools can agents access), while ACP handles the ",(0,i.jsx)(t.em,{children:"where"})," (where the agent lives in your workflow). Together, they create an ecosystem where developers can mix and match the best tools without vendor lock-in."]}),"\n",(0,i.jsx)(t.p,{children:"The goose team continues working to keep goose cutting-edge in the AI agent space, and we're excited about a future where open protocols let developers work however they work best."}),"\n",(0,i.jsx)(t.h2,{id:"see-acp-in-action",children:"See ACP in Action"}),"\n",(0,i.jsx)(t.p,{children:"If you're ready to see how fast and simple this setup really is, watch the full livestream recording of my ACP setup with goose below"}),"\n",(0,i.jsx)("iframe",{class:"aspect-ratio",src:"https://www.youtube.com/embed/Hvu5KDTb6JE",title:"Vibe Code with goose: Intro to ACP",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:["Ready to integrate goose directly into your editor? Get started with our ",(0,i.jsx)(t.a,{href:"https://block.github.io/goose/docs/guides/acp-clients",children:"ACP setup guide"})," and share your experience in our ",(0,i.jsx)(t.a,{href:"http://discord.gg/goose-oss",children:"Discord community"}),"."]})}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("meta",{property:"og:title",content:"Intro to Agent Client Protocol (ACP): The Standard for AI Agent-Editor Integration"}),(0,i.jsx)("meta",{property:"og:type",content:"article"}),(0,i.jsx)("meta",{property:"og:url",content:"https://block.github.io/goose/blog/2025/10/24/intro-to-agent-client-protocol-acp"}),(0,i.jsx)("meta",{property:"og:description",content:"Fix the awkward gap between AI agents and code editors with the Agent Client Protocol (ACP). Learn why this new open standard makes agents like goose truly editor-agnostic, improving AI-human collaboration and restoring developer flow state. ACP works alongside protocols like MCP to create an open AI tooling ecosystem."}),(0,i.jsx)("meta",{property:"og:image",content:"https://block.github.io/goose/assets/images/choose-your-ide-c308664c1783e1651d9a4f4d6ff7d731.png"}),(0,i.jsx)("meta",{name:"twitter:card",content:"summary_large_image"}),(0,i.jsx)("meta",{property:"twitter:domain",content:"block.github.io/goose"}),(0,i.jsx)("meta",{name:"twitter:title",content:"Intro to Agent Client Protocol (ACP): The Standard for AI Agent-Editor Integration"}),(0,i.jsx)("meta",{name:"twitter:description",content:"Fix the awkward gap between AI agents and code editors with the Agent Client Protocol (ACP). Learn why this new open standard makes agents like goose truly editor-agnostic, improving AI-human collaboration and restoring developer flow state. ACP works alongside protocols like MCP to create an open AI tooling ecosystem."}),(0,i.jsx)("meta",{name:"twitter:image",content:"https://block.github.io/goose/assets/images/choose-your-ide-c308664c1783e1651d9a4f4d6ff7d731.png"})]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},85016:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/choose-your-ide-c308664c1783e1651d9a4f4d6ff7d731.png"}}]);